// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package drift

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize_user" instruction.
func NewInitializeUserInstruction(
	// Params:
	subAccountIdParam uint16,
	nameParam [32]uint8,

	// Accounts:
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeUser[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_user_stats" instruction.
func NewInitializeUserStatsInstruction(
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_signed_msg_user_orders" instruction.
func NewInitializeSignedMsgUserOrdersInstruction(
	// Params:
	numOrdersParam uint16,

	// Accounts:
	signedMsgUserOrdersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeSignedMsgUserOrders[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `numOrdersParam`:
		err = enc__.Encode(numOrdersParam)
		if err != nil {
			return nil, errors.NewField("numOrdersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signed_msg_user_orders": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgUserOrdersAccount, true, false))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "resize_signed_msg_user_orders" instruction.
func NewResizeSignedMsgUserOrdersInstruction(
	// Params:
	numOrdersParam uint16,

	// Accounts:
	signedMsgUserOrdersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ResizeSignedMsgUserOrders[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `numOrdersParam`:
		err = enc__.Encode(numOrdersParam)
		if err != nil {
			return nil, errors.NewField("numOrdersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signed_msg_user_orders": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgUserOrdersAccount, true, false))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "user": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_signed_msg_ws_delegates" instruction.
func NewInitializeSignedMsgWsDelegatesInstruction(
	// Params:
	delegatesParam []solanago.PublicKey,

	// Accounts:
	signedMsgWsDelegatesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeSignedMsgWsDelegates[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `delegatesParam`:
		err = enc__.Encode(delegatesParam)
		if err != nil {
			return nil, errors.NewField("delegatesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signed_msg_ws_delegates": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgWsDelegatesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "change_signed_msg_ws_delegate_status" instruction.
func NewChangeSignedMsgWsDelegateStatusInstruction(
	// Params:
	delegateParam solanago.PublicKey,
	addParam bool,

	// Accounts:
	signedMsgWsDelegatesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ChangeSignedMsgWsDelegateStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `delegateParam`:
		err = enc__.Encode(delegateParam)
		if err != nil {
			return nil, errors.NewField("delegateParam", err)
		}
		// Serialize `addParam`:
		err = enc__.Encode(addParam)
		if err != nil {
			return nil, errors.NewField("addParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signed_msg_ws_delegates": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgWsDelegatesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_fuel_overflow" instruction.
func NewInitializeFuelOverflowInstruction(
	fuelOverflowAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "fuel_overflow": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fuelOverflowAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "sweep_fuel" instruction.
func NewSweepFuelInstruction(
	fuelOverflowAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "fuel_overflow": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fuelOverflowAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 3 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "reset_fuel_season" instruction.
func NewResetFuelSeasonInstruction(
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_referrer_name" instruction.
func NewInitializeReferrerNameInstruction(
	// Params:
	nameParam [32]uint8,

	// Accounts:
	referrerNameAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeReferrerName[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "referrer_name": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referrerNameAccount, true, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit" instruction.
func NewDepositInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,
	reduceOnlyParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Deposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `reduceOnlyParam`:
		err = enc__.Encode(reduceOnlyParam)
		if err != nil {
			return nil, errors.NewField("reduceOnlyParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 5 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw" instruction.
func NewWithdrawInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,
	reduceOnlyParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Withdraw[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `reduceOnlyParam`:
		err = enc__.Encode(reduceOnlyParam)
		if err != nil {
			return nil, errors.NewField("reduceOnlyParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 5 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 6 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 7 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_deposit" instruction.
func NewTransferDepositInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,

	// Accounts:
	fromUserAccount solanago.PublicKey,
	toUserAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferDeposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "from_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fromUserAccount, true, false))
		// Account 1 "to_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toUserAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 5 "spot_market_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_pools" instruction.
func NewTransferPoolsInstruction(
	// Params:
	depositFromMarketIndexParam uint16,
	depositToMarketIndexParam uint16,
	borrowFromMarketIndexParam uint16,
	borrowToMarketIndexParam uint16,
	depositAmountParam *uint64,
	borrowAmountParam *uint64,

	// Accounts:
	fromUserAccount solanago.PublicKey,
	toUserAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	depositFromSpotMarketVaultAccount solanago.PublicKey,
	depositToSpotMarketVaultAccount solanago.PublicKey,
	borrowFromSpotMarketVaultAccount solanago.PublicKey,
	borrowToSpotMarketVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferPools[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `depositFromMarketIndexParam`:
		err = enc__.Encode(depositFromMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("depositFromMarketIndexParam", err)
		}
		// Serialize `depositToMarketIndexParam`:
		err = enc__.Encode(depositToMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("depositToMarketIndexParam", err)
		}
		// Serialize `borrowFromMarketIndexParam`:
		err = enc__.Encode(borrowFromMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("borrowFromMarketIndexParam", err)
		}
		// Serialize `borrowToMarketIndexParam`:
		err = enc__.Encode(borrowToMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("borrowToMarketIndexParam", err)
		}
		// Serialize `depositAmountParam` (optional):
		{
			if depositAmountParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("depositAmountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("depositAmountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(depositAmountParam)
				if err != nil {
					return nil, errors.NewField("depositAmountParam", err)
				}
			}
		}
		// Serialize `borrowAmountParam` (optional):
		{
			if borrowAmountParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("borrowAmountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("borrowAmountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(borrowAmountParam)
				if err != nil {
					return nil, errors.NewField("borrowAmountParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "from_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fromUserAccount, true, false))
		// Account 1 "to_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toUserAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 5 "deposit_from_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(depositFromSpotMarketVaultAccount, true, false))
		// Account 6 "deposit_to_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(depositToSpotMarketVaultAccount, true, false))
		// Account 7 "borrow_from_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(borrowFromSpotMarketVaultAccount, true, false))
		// Account 8 "borrow_to_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(borrowToSpotMarketVaultAccount, true, false))
		// Account 9 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_perp_position" instruction.
func NewTransferPerpPositionInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam *int64,

	// Accounts:
	fromUserAccount solanago.PublicKey,
	toUserAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferPerpPosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam` (optional):
		{
			if amountParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("amountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("amountParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(amountParam)
				if err != nil {
					return nil, errors.NewField("amountParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "from_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fromUserAccount, true, false))
		// Account 1 "to_user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toUserAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_perp_order" instruction.
func NewPlacePerpOrderInstruction(
	// Params:
	paramsParam OrderParams,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlacePerpOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel_order" instruction.
func NewCancelOrderInstruction(
	// Params:
	orderIdParam *uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdParam` (optional):
		{
			if orderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(orderIdParam)
				if err != nil {
					return nil, errors.NewField("orderIdParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel_order_by_user_id" instruction.
func NewCancelOrderByUserIdInstruction(
	// Params:
	userOrderIdParam uint8,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelOrderByUserId[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `userOrderIdParam`:
		err = enc__.Encode(userOrderIdParam)
		if err != nil {
			return nil, errors.NewField("userOrderIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel_orders" instruction.
func NewCancelOrdersInstruction(
	// Params:
	marketTypeParam *MarketType,
	marketIndexParam *uint16,
	directionParam *PositionDirection,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelOrders[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketTypeParam` (optional):
		{
			if marketTypeParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("marketTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("marketTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(marketTypeParam)
				if err != nil {
					return nil, errors.NewField("marketTypeParam", err)
				}
			}
		}
		// Serialize `marketIndexParam` (optional):
		{
			if marketIndexParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("marketIndexParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("marketIndexParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(marketIndexParam)
				if err != nil {
					return nil, errors.NewField("marketIndexParam", err)
				}
			}
		}
		// Serialize `directionParam` (optional):
		{
			if directionParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("directionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("directionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(directionParam)
				if err != nil {
					return nil, errors.NewField("directionParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel_orders_by_ids" instruction.
func NewCancelOrdersByIdsInstruction(
	// Params:
	orderIdsParam []uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelOrdersByIds[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdsParam`:
		err = enc__.Encode(orderIdsParam)
		if err != nil {
			return nil, errors.NewField("orderIdsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "modify_order" instruction.
func NewModifyOrderInstruction(
	// Params:
	orderIdParam *uint32,
	modifyOrderParamsParam ModifyOrderParams,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ModifyOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdParam` (optional):
		{
			if orderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(orderIdParam)
				if err != nil {
					return nil, errors.NewField("orderIdParam", err)
				}
			}
		}
		// Serialize `modifyOrderParamsParam`:
		err = enc__.Encode(modifyOrderParamsParam)
		if err != nil {
			return nil, errors.NewField("modifyOrderParamsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "modify_order_by_user_id" instruction.
func NewModifyOrderByUserIdInstruction(
	// Params:
	userOrderIdParam uint8,
	modifyOrderParamsParam ModifyOrderParams,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ModifyOrderByUserId[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `userOrderIdParam`:
		err = enc__.Encode(userOrderIdParam)
		if err != nil {
			return nil, errors.NewField("userOrderIdParam", err)
		}
		// Serialize `modifyOrderParamsParam`:
		err = enc__.Encode(modifyOrderParamsParam)
		if err != nil {
			return nil, errors.NewField("modifyOrderParamsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_and_take_perp_order" instruction.
func NewPlaceAndTakePerpOrderInstruction(
	// Params:
	paramsParam OrderParams,
	successConditionParam *uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceAndTakePerpOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `successConditionParam` (optional):
		{
			if successConditionParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("successConditionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("successConditionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(successConditionParam)
				if err != nil {
					return nil, errors.NewField("successConditionParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_and_make_perp_order" instruction.
func NewPlaceAndMakePerpOrderInstruction(
	// Params:
	paramsParam OrderParams,
	takerOrderIdParam uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	takerAccount solanago.PublicKey,
	takerStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceAndMakePerpOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `takerOrderIdParam`:
		err = enc__.Encode(takerOrderIdParam)
		if err != nil {
			return nil, errors.NewField("takerOrderIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "taker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerAccount, true, false))
		// Account 4 "taker_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerStatsAccount, true, false))
		// Account 5 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_and_make_signed_msg_perp_order" instruction.
func NewPlaceAndMakeSignedMsgPerpOrderInstruction(
	// Params:
	paramsParam OrderParams,
	signedMsgOrderUuidParam [8]uint8,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	takerAccount solanago.PublicKey,
	takerStatsAccount solanago.PublicKey,
	takerSignedMsgUserOrdersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceAndMakeSignedMsgPerpOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `signedMsgOrderUuidParam`:
		err = enc__.Encode(signedMsgOrderUuidParam)
		if err != nil {
			return nil, errors.NewField("signedMsgOrderUuidParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "taker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerAccount, true, false))
		// Account 4 "taker_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerStatsAccount, true, false))
		// Account 5 "taker_signed_msg_user_orders": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerSignedMsgUserOrdersAccount, false, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_signed_msg_taker_order" instruction.
func NewPlaceSignedMsgTakerOrderInstruction(
	// Params:
	signedMsgOrderParamsMessageBytesParam []byte,
	isDelegateSignerParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	signedMsgUserOrdersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	ixSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceSignedMsgTakerOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signedMsgOrderParamsMessageBytesParam`:
		err = enc__.Encode(signedMsgOrderParamsMessageBytesParam)
		if err != nil {
			return nil, errors.NewField("signedMsgOrderParamsMessageBytesParam", err)
		}
		// Serialize `isDelegateSignerParam`:
		err = enc__.Encode(isDelegateSignerParam)
		if err != nil {
			return nil, errors.NewField("isDelegateSignerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "signed_msg_user_orders": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgUserOrdersAccount, true, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 5 "ix_sysvar": Read-only, Non-signer, Required
		// the supplied Sysvar could be anything else.
		// The Instruction Sysvar has not been implemented
		// in the Anchor framework yet, so this is the safe approach.
		accounts__.Append(solanago.NewAccountMeta(ixSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_spot_order" instruction.
func NewPlaceSpotOrderInstruction(
	// Params:
	paramsParam OrderParams,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceSpotOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_and_take_spot_order" instruction.
func NewPlaceAndTakeSpotOrderInstruction(
	// Params:
	paramsParam OrderParams,
	fulfillmentTypeParam *SpotFulfillmentType,
	makerOrderIdParam *uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceAndTakeSpotOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `fulfillmentTypeParam` (optional):
		{
			if fulfillmentTypeParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fulfillmentTypeParam)
				if err != nil {
					return nil, errors.NewField("fulfillmentTypeParam", err)
				}
			}
		}
		// Serialize `makerOrderIdParam` (optional):
		{
			if makerOrderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(makerOrderIdParam)
				if err != nil {
					return nil, errors.NewField("makerOrderIdParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_and_make_spot_order" instruction.
func NewPlaceAndMakeSpotOrderInstruction(
	// Params:
	paramsParam OrderParams,
	takerOrderIdParam uint32,
	fulfillmentTypeParam *SpotFulfillmentType,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	takerAccount solanago.PublicKey,
	takerStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceAndMakeSpotOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `takerOrderIdParam`:
		err = enc__.Encode(takerOrderIdParam)
		if err != nil {
			return nil, errors.NewField("takerOrderIdParam", err)
		}
		// Serialize `fulfillmentTypeParam` (optional):
		{
			if fulfillmentTypeParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fulfillmentTypeParam)
				if err != nil {
					return nil, errors.NewField("fulfillmentTypeParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "taker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerAccount, true, false))
		// Account 4 "taker_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(takerStatsAccount, true, false))
		// Account 5 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "place_orders" instruction.
func NewPlaceOrdersInstruction(
	// Params:
	paramsParam []OrderParams,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PlaceOrders[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "begin_swap" instruction.
func NewBeginSwapInstruction(
	// Params:
	inMarketIndexParam uint16,
	outMarketIndexParam uint16,
	amountInParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	outSpotMarketVaultAccount solanago.PublicKey,
	inSpotMarketVaultAccount solanago.PublicKey,
	outTokenAccountAccount solanago.PublicKey,
	inTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BeginSwap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inMarketIndexParam`:
		err = enc__.Encode(inMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("inMarketIndexParam", err)
		}
		// Serialize `outMarketIndexParam`:
		err = enc__.Encode(outMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("outMarketIndexParam", err)
		}
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "out_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outSpotMarketVaultAccount, true, false))
		// Account 5 "in_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inSpotMarketVaultAccount, true, false))
		// Account 6 "out_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outTokenAccountAccount, true, false))
		// Account 7 "in_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inTokenAccountAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 10 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "end_swap" instruction.
func NewEndSwapInstruction(
	// Params:
	inMarketIndexParam uint16,
	outMarketIndexParam uint16,
	limitPriceParam *uint64,
	reduceOnlyParam *SwapReduceOnly,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	outSpotMarketVaultAccount solanago.PublicKey,
	inSpotMarketVaultAccount solanago.PublicKey,
	outTokenAccountAccount solanago.PublicKey,
	inTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EndSwap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inMarketIndexParam`:
		err = enc__.Encode(inMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("inMarketIndexParam", err)
		}
		// Serialize `outMarketIndexParam`:
		err = enc__.Encode(outMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("outMarketIndexParam", err)
		}
		// Serialize `limitPriceParam` (optional):
		{
			if limitPriceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(limitPriceParam)
				if err != nil {
					return nil, errors.NewField("limitPriceParam", err)
				}
			}
		}
		// Serialize `reduceOnlyParam` (optional):
		{
			if reduceOnlyParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("reduceOnlyParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("reduceOnlyParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(reduceOnlyParam)
				if err != nil {
					return nil, errors.NewField("reduceOnlyParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "out_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outSpotMarketVaultAccount, true, false))
		// Account 5 "in_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inSpotMarketVaultAccount, true, false))
		// Account 6 "out_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outTokenAccountAccount, true, false))
		// Account 7 "in_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inTokenAccountAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 10 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_name" instruction.
func NewUpdateUserNameInstruction(
	// Params:
	subAccountIdParam uint16,
	nameParam [32]uint8,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserName[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_custom_margin_ratio" instruction.
func NewUpdateUserCustomMarginRatioInstruction(
	// Params:
	subAccountIdParam uint16,
	marginRatioParam uint32,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserCustomMarginRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `marginRatioParam`:
		err = enc__.Encode(marginRatioParam)
		if err != nil {
			return nil, errors.NewField("marginRatioParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_perp_position_custom_margin_ratio" instruction.
func NewUpdateUserPerpPositionCustomMarginRatioInstruction(
	// Params:
	subAccountIdParam uint16,
	perpMarketIndexParam uint16,
	marginRatioParam uint16,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserPerpPositionCustomMarginRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `perpMarketIndexParam`:
		err = enc__.Encode(perpMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("perpMarketIndexParam", err)
		}
		// Serialize `marginRatioParam`:
		err = enc__.Encode(marginRatioParam)
		if err != nil {
			return nil, errors.NewField("marginRatioParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_margin_trading_enabled" instruction.
func NewUpdateUserMarginTradingEnabledInstruction(
	// Params:
	subAccountIdParam uint16,
	marginTradingEnabledParam bool,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserMarginTradingEnabled[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `marginTradingEnabledParam`:
		err = enc__.Encode(marginTradingEnabledParam)
		if err != nil {
			return nil, errors.NewField("marginTradingEnabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_pool_id" instruction.
func NewUpdateUserPoolIdInstruction(
	// Params:
	subAccountIdParam uint16,
	poolIdParam uint8,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserPoolId[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `poolIdParam`:
		err = enc__.Encode(poolIdParam)
		if err != nil {
			return nil, errors.NewField("poolIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_delegate" instruction.
func NewUpdateUserDelegateInstruction(
	// Params:
	subAccountIdParam uint16,
	delegateParam solanago.PublicKey,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserDelegate[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `delegateParam`:
		err = enc__.Encode(delegateParam)
		if err != nil {
			return nil, errors.NewField("delegateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_reduce_only" instruction.
func NewUpdateUserReduceOnlyInstruction(
	// Params:
	subAccountIdParam uint16,
	reduceOnlyParam bool,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserReduceOnly[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `reduceOnlyParam`:
		err = enc__.Encode(reduceOnlyParam)
		if err != nil {
			return nil, errors.NewField("reduceOnlyParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_advanced_lp" instruction.
func NewUpdateUserAdvancedLpInstruction(
	// Params:
	subAccountIdParam uint16,
	advancedLpParam bool,

	// Accounts:
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserAdvancedLp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `advancedLpParam`:
		err = enc__.Encode(advancedLpParam)
		if err != nil {
			return nil, errors.NewField("advancedLpParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_protected_maker_orders" instruction.
func NewUpdateUserProtectedMakerOrdersInstruction(
	// Params:
	subAccountIdParam uint16,
	protectedMakerOrdersParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	protectedMakerModeConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateUserProtectedMakerOrders[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
		// Serialize `protectedMakerOrdersParam`:
		err = enc__.Encode(protectedMakerOrdersParam)
		if err != nil {
			return nil, errors.NewField("protectedMakerOrdersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "protected_maker_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protectedMakerModeConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_user" instruction.
func NewDeleteUserInstruction(
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "force_delete_user" instruction.
func NewForceDeleteUserInstruction(
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	keeperAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "authority": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, false))
		// Account 4 "keeper": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, true, true))
		// Account 5 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "delete_signed_msg_user_orders" instruction.
func NewDeleteSignedMsgUserOrdersInstruction(
	signedMsgUserOrdersAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signed_msg_user_orders": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signedMsgUserOrdersAccount, true, false))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "reclaim_rent" instruction.
func NewReclaimRentInstruction(
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 1 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "enable_user_high_leverage_mode" instruction.
func NewEnableUserHighLeverageModeInstruction(
	// Params:
	subAccountIdParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	highLeverageModeConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EnableUserHighLeverageMode[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subAccountIdParam`:
		err = enc__.Encode(subAccountIdParam)
		if err != nil {
			return nil, errors.NewField("subAccountIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "high_leverage_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(highLeverageModeConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "fill_perp_order" instruction.
func NewFillPerpOrderInstruction(
	// Params:
	orderIdParam *uint32,
	makerOrderIdParam *uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	fillerStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FillPerpOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdParam` (optional):
		{
			if orderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(orderIdParam)
				if err != nil {
					return nil, errors.NewField("orderIdParam", err)
				}
			}
		}
		// Serialize `makerOrderIdParam` (optional):
		{
			if makerOrderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(makerOrderIdParam)
				if err != nil {
					return nil, errors.NewField("makerOrderIdParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "filler_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "revert_fill" instruction.
func NewRevertFillInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	fillerStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "filler_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "fill_spot_order" instruction.
func NewFillSpotOrderInstruction(
	// Params:
	orderIdParam *uint32,
	fulfillmentTypeParam *SpotFulfillmentType,
	makerOrderIdParam *uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	fillerStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FillSpotOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdParam` (optional):
		{
			if orderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("orderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(orderIdParam)
				if err != nil {
					return nil, errors.NewField("orderIdParam", err)
				}
			}
		}
		// Serialize `fulfillmentTypeParam` (optional):
		{
			if fulfillmentTypeParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fulfillmentTypeParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fulfillmentTypeParam)
				if err != nil {
					return nil, errors.NewField("fulfillmentTypeParam", err)
				}
			}
		}
		// Serialize `makerOrderIdParam` (optional):
		{
			if makerOrderIdParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("makerOrderIdParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(makerOrderIdParam)
				if err != nil {
					return nil, errors.NewField("makerOrderIdParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "filler_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "trigger_order" instruction.
func NewTriggerOrderInstruction(
	// Params:
	orderIdParam uint32,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TriggerOrder[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderIdParam`:
		err = enc__.Encode(orderIdParam)
		if err != nil {
			return nil, errors.NewField("orderIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "force_cancel_orders" instruction.
func NewForceCancelOrdersInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_user_idle" instruction.
func NewUpdateUserIdleInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "log_user_balances" instruction.
func NewLogUserBalancesInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "disable_user_high_leverage_mode" instruction.
func NewDisableUserHighLeverageModeInstruction(
	// Params:
	disableMaintenanceParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	highLeverageModeConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableUserHighLeverageMode[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `disableMaintenanceParam`:
		err = enc__.Encode(disableMaintenanceParam)
		if err != nil {
			return nil, errors.NewField("disableMaintenanceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 3 "high_leverage_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(highLeverageModeConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_fuel_bonus" instruction.
func NewUpdateUserFuelBonusInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_user_stats_referrer_status" instruction.
func NewUpdateUserStatsReferrerStatusInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_user_open_orders_count" instruction.
func NewUpdateUserOpenOrdersCountInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	fillerAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "filler": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(fillerAccount, true, false))
		// Account 3 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "admin_disable_update_perp_bid_ask_twap" instruction.
func NewAdminDisableUpdatePerpBidAskTwapInstruction(
	// Params:
	disableParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AdminDisableUpdatePerpBidAskTwap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `disableParam`:
		err = enc__.Encode(disableParam)
		if err != nil {
			return nil, errors.NewField("disableParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "settle_pnl" instruction.
func NewSettlePnlInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SettlePnl[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "spot_market_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "settle_multiple_pnls" instruction.
func NewSettleMultiplePnlsInstruction(
	// Params:
	marketIndexesParam []uint16,
	modeParam SettlePnlMode,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SettleMultiplePnls[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexesParam`:
		err = enc__.Encode(marketIndexesParam)
		if err != nil {
			return nil, errors.NewField("marketIndexesParam", err)
		}
		// Serialize `modeParam`:
		err = enc__.Encode(modeParam)
		if err != nil {
			return nil, errors.NewField("modeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "spot_market_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "settle_funding_payment" instruction.
func NewSettleFundingPaymentInstruction(
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "settle_expired_market" instruction.
func NewSettleExpiredMarketInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SettleExpiredMarket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_perp" instruction.
func NewLiquidatePerpInstruction(
	// Params:
	marketIndexParam uint16,
	liquidatorMaxBaseAssetAmountParam uint64,
	limitPriceParam *uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidatePerp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `liquidatorMaxBaseAssetAmountParam`:
		err = enc__.Encode(liquidatorMaxBaseAssetAmountParam)
		if err != nil {
			return nil, errors.NewField("liquidatorMaxBaseAssetAmountParam", err)
		}
		// Serialize `limitPriceParam` (optional):
		{
			if limitPriceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(limitPriceParam)
				if err != nil {
					return nil, errors.NewField("limitPriceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_perp_with_fill" instruction.
func NewLiquidatePerpWithFillInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidatePerpWithFill[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_spot" instruction.
func NewLiquidateSpotInstruction(
	// Params:
	assetMarketIndexParam uint16,
	liabilityMarketIndexParam uint16,
	liquidatorMaxLiabilityTransferParam binary.Uint128,
	limitPriceParam *uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidateSpot[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `assetMarketIndexParam`:
		err = enc__.Encode(assetMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("assetMarketIndexParam", err)
		}
		// Serialize `liabilityMarketIndexParam`:
		err = enc__.Encode(liabilityMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("liabilityMarketIndexParam", err)
		}
		// Serialize `liquidatorMaxLiabilityTransferParam`:
		err = enc__.Encode(liquidatorMaxLiabilityTransferParam)
		if err != nil {
			return nil, errors.NewField("liquidatorMaxLiabilityTransferParam", err)
		}
		// Serialize `limitPriceParam` (optional):
		{
			if limitPriceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(limitPriceParam)
				if err != nil {
					return nil, errors.NewField("limitPriceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_spot_with_swap_begin" instruction.
func NewLiquidateSpotWithSwapBeginInstruction(
	// Params:
	assetMarketIndexParam uint16,
	liabilityMarketIndexParam uint16,
	swapAmountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	liabilitySpotMarketVaultAccount solanago.PublicKey,
	assetSpotMarketVaultAccount solanago.PublicKey,
	liabilityTokenAccountAccount solanago.PublicKey,
	assetTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidateSpotWithSwapBegin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `assetMarketIndexParam`:
		err = enc__.Encode(assetMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("assetMarketIndexParam", err)
		}
		// Serialize `liabilityMarketIndexParam`:
		err = enc__.Encode(liabilityMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("liabilityMarketIndexParam", err)
		}
		// Serialize `swapAmountParam`:
		err = enc__.Encode(swapAmountParam)
		if err != nil {
			return nil, errors.NewField("swapAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 6 "liability_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liabilitySpotMarketVaultAccount, true, false))
		// Account 7 "asset_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(assetSpotMarketVaultAccount, true, false))
		// Account 8 "liability_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liabilityTokenAccountAccount, true, false))
		// Account 9 "asset_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(assetTokenAccountAccount, true, false))
		// Account 10 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 11 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 12 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_spot_with_swap_end" instruction.
func NewLiquidateSpotWithSwapEndInstruction(
	// Params:
	assetMarketIndexParam uint16,
	liabilityMarketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	liabilitySpotMarketVaultAccount solanago.PublicKey,
	assetSpotMarketVaultAccount solanago.PublicKey,
	liabilityTokenAccountAccount solanago.PublicKey,
	assetTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidateSpotWithSwapEnd[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `assetMarketIndexParam`:
		err = enc__.Encode(assetMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("assetMarketIndexParam", err)
		}
		// Serialize `liabilityMarketIndexParam`:
		err = enc__.Encode(liabilityMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("liabilityMarketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 6 "liability_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liabilitySpotMarketVaultAccount, true, false))
		// Account 7 "asset_spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(assetSpotMarketVaultAccount, true, false))
		// Account 8 "liability_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liabilityTokenAccountAccount, true, false))
		// Account 9 "asset_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(assetTokenAccountAccount, true, false))
		// Account 10 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 11 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 12 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_borrow_for_perp_pnl" instruction.
func NewLiquidateBorrowForPerpPnlInstruction(
	// Params:
	perpMarketIndexParam uint16,
	spotMarketIndexParam uint16,
	liquidatorMaxLiabilityTransferParam binary.Uint128,
	limitPriceParam *uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidateBorrowForPerpPnl[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `perpMarketIndexParam`:
		err = enc__.Encode(perpMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("perpMarketIndexParam", err)
		}
		// Serialize `spotMarketIndexParam`:
		err = enc__.Encode(spotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("spotMarketIndexParam", err)
		}
		// Serialize `liquidatorMaxLiabilityTransferParam`:
		err = enc__.Encode(liquidatorMaxLiabilityTransferParam)
		if err != nil {
			return nil, errors.NewField("liquidatorMaxLiabilityTransferParam", err)
		}
		// Serialize `limitPriceParam` (optional):
		{
			if limitPriceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(limitPriceParam)
				if err != nil {
					return nil, errors.NewField("limitPriceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "liquidate_perp_pnl_for_deposit" instruction.
func NewLiquidatePerpPnlForDepositInstruction(
	// Params:
	perpMarketIndexParam uint16,
	spotMarketIndexParam uint16,
	liquidatorMaxPnlTransferParam binary.Uint128,
	limitPriceParam *uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LiquidatePerpPnlForDeposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `perpMarketIndexParam`:
		err = enc__.Encode(perpMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("perpMarketIndexParam", err)
		}
		// Serialize `spotMarketIndexParam`:
		err = enc__.Encode(spotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("spotMarketIndexParam", err)
		}
		// Serialize `liquidatorMaxPnlTransferParam`:
		err = enc__.Encode(liquidatorMaxPnlTransferParam)
		if err != nil {
			return nil, errors.NewField("liquidatorMaxPnlTransferParam", err)
		}
		// Serialize `limitPriceParam` (optional):
		{
			if limitPriceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("limitPriceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(limitPriceParam)
				if err != nil {
					return nil, errors.NewField("limitPriceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_user_status_to_being_liquidated" instruction.
func NewSetUserStatusToBeingLiquidatedInstruction(
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "resolve_perp_pnl_deficit" instruction.
func NewResolvePerpPnlDeficitInstruction(
	// Params:
	spotMarketIndexParam uint16,
	perpMarketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ResolvePerpPnlDeficit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `spotMarketIndexParam`:
		err = enc__.Encode(spotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("spotMarketIndexParam", err)
		}
		// Serialize `perpMarketIndexParam`:
		err = enc__.Encode(perpMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("perpMarketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 3 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 4 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "resolve_perp_bankruptcy" instruction.
func NewResolvePerpBankruptcyInstruction(
	// Params:
	quoteSpotMarketIndexParam uint16,
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ResolvePerpBankruptcy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `quoteSpotMarketIndexParam`:
		err = enc__.Encode(quoteSpotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("quoteSpotMarketIndexParam", err)
		}
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 6 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 7 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 8 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 9 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "resolve_spot_bankruptcy" instruction.
func NewResolveSpotBankruptcyInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	liquidatorAccount solanago.PublicKey,
	liquidatorStatsAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ResolveSpotBankruptcy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "liquidator": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorAccount, true, false))
		// Account 3 "liquidator_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(liquidatorStatsAccount, true, false))
		// Account 4 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 6 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 7 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 8 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 9 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "settle_revenue_to_insurance_fund" instruction.
func NewSettleRevenueToInsuranceFundInstruction(
	// Params:
	spotMarketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SettleRevenueToInsuranceFund[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `spotMarketIndexParam`:
		err = enc__.Encode(spotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("spotMarketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 3 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 4 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_funding_rate" instruction.
func NewUpdateFundingRateInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFundingRate[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_prelaunch_oracle" instruction.
func NewUpdatePrelaunchOracleInstruction(
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, false, false))
		// Account 2 "oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_perp_bid_ask_twap" instruction.
func NewUpdatePerpBidAskTwapInstruction(
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	keeperStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 3 "keeper_stats": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperStatsAccount, false, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_spot_market_cumulative_interest" instruction.
func NewUpdateSpotMarketCumulativeInterestInstruction(
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 3 "spot_market_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_amms" instruction.
func NewUpdateAmmsInstruction(
	// Params:
	marketIndexesParam []uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAmms[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexesParam`:
		err = enc__.Encode(marketIndexesParam)
		if err != nil {
			return nil, errors.NewField("marketIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_expiry" instruction.
func NewUpdateSpotMarketExpiryInstruction(
	// Params:
	expiryTsParam int64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketExpiry[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `expiryTsParam`:
		err = enc__.Encode(expiryTsParam)
		if err != nil {
			return nil, errors.NewField("expiryTsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_user_quote_asset_insurance_stake" instruction.
func NewUpdateUserQuoteAssetInsuranceStakeInstruction(
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 4 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 5 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_user_gov_token_insurance_stake" instruction.
func NewUpdateUserGovTokenInsuranceStakeInstruction(
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	signerAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 4 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 5 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_insurance_fund_stake" instruction.
func NewInitializeInsuranceFundStakeInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeInsuranceFundStake[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, false, false))
		// Account 1 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_insurance_fund_stake" instruction.
func NewAddInsuranceFundStakeInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddInsuranceFundStake[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 5 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 6 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 7 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 8 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 9 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "request_remove_insurance_fund_stake" instruction.
func NewRequestRemoveInsuranceFundStakeInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,

	// Accounts:
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RequestRemoveInsuranceFundStake[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 1 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel_request_remove_insurance_fund_stake" instruction.
func NewCancelRequestRemoveInsuranceFundStakeInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CancelRequestRemoveInsuranceFundStake[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 1 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 2 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 3 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_insurance_fund_stake" instruction.
func NewRemoveInsuranceFundStakeInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveInsuranceFundStake[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 5 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 6 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 7 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_protocol_if_shares" instruction.
func NewTransferProtocolIfSharesInstruction(
	// Params:
	marketIndexParam uint16,
	sharesParam binary.Uint128,

	// Accounts:
	signerAccount solanago.PublicKey,
	transferConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	insuranceFundStakeAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferProtocolIfShares[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `sharesParam`:
		err = enc__.Encode(sharesParam)
		if err != nil {
			return nil, errors.NewField("sharesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, false, true))
		// Account 1 "transfer_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(transferConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 4 "insurance_fund_stake": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundStakeAccount, true, false))
		// Account 5 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 7 "insurance_fund_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "begin_insurance_fund_swap" instruction.
func NewBeginInsuranceFundSwapInstruction(
	// Params:
	inMarketIndexParam uint16,
	outMarketIndexParam uint16,
	amountInParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	outInsuranceFundVaultAccount solanago.PublicKey,
	inInsuranceFundVaultAccount solanago.PublicKey,
	outTokenAccountAccount solanago.PublicKey,
	inTokenAccountAccount solanago.PublicKey,
	ifRebalanceConfigAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BeginInsuranceFundSwap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inMarketIndexParam`:
		err = enc__.Encode(inMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("inMarketIndexParam", err)
		}
		// Serialize `outMarketIndexParam`:
		err = enc__.Encode(outMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("outMarketIndexParam", err)
		}
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "out_insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outInsuranceFundVaultAccount, true, false))
		// Account 3 "in_insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inInsuranceFundVaultAccount, true, false))
		// Account 4 "out_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outTokenAccountAccount, true, false))
		// Account 5 "in_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inTokenAccountAccount, true, false))
		// Account 6 "if_rebalance_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ifRebalanceConfigAccount, true, false))
		// Account 7 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 9 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "end_insurance_fund_swap" instruction.
func NewEndInsuranceFundSwapInstruction(
	// Params:
	inMarketIndexParam uint16,
	outMarketIndexParam uint16,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	outInsuranceFundVaultAccount solanago.PublicKey,
	inInsuranceFundVaultAccount solanago.PublicKey,
	outTokenAccountAccount solanago.PublicKey,
	inTokenAccountAccount solanago.PublicKey,
	ifRebalanceConfigAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	instructionsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EndInsuranceFundSwap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `inMarketIndexParam`:
		err = enc__.Encode(inMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("inMarketIndexParam", err)
		}
		// Serialize `outMarketIndexParam`:
		err = enc__.Encode(outMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("outMarketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "out_insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outInsuranceFundVaultAccount, true, false))
		// Account 3 "in_insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inInsuranceFundVaultAccount, true, false))
		// Account 4 "out_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(outTokenAccountAccount, true, false))
		// Account 5 "in_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(inTokenAccountAccount, true, false))
		// Account 6 "if_rebalance_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ifRebalanceConfigAccount, true, false))
		// Account 7 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 9 "instructions": Read-only, Non-signer, Required
		// Instructions Sysvar for instruction introspection
		accounts__.Append(solanago.NewAccountMeta(instructionsAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_protocol_if_shares_to_revenue_pool" instruction.
func NewTransferProtocolIfSharesToRevenuePoolInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	ifRebalanceConfigAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferProtocolIfSharesToRevenuePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 3 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 4 "if_rebalance_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ifRebalanceConfigAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_pyth_pull_oracle" instruction.
func NewUpdatePythPullOracleInstruction(
	// Params:
	feedIdParam [32]uint8,
	paramsParam []byte,

	// Accounts:
	keeperAccount solanago.PublicKey,
	pythSolanaReceiverAccount solanago.PublicKey,
	encodedVaaAccount solanago.PublicKey,
	priceFeedAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePythPullOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feedIdParam`:
		err = enc__.Encode(feedIdParam)
		if err != nil {
			return nil, errors.NewField("feedIdParam", err)
		}
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "keeper": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, true, true))
		// Account 1 "pyth_solana_receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(pythSolanaReceiverAccount, false, false))
		// Account 2 "encoded_vaa": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(encodedVaaAccount, false, false))
		// Account 3 "price_feed": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(priceFeedAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "post_pyth_pull_oracle_update_atomic" instruction.
func NewPostPythPullOracleUpdateAtomicInstruction(
	// Params:
	feedIdParam [32]uint8,
	paramsParam []byte,

	// Accounts:
	keeperAccount solanago.PublicKey,
	pythSolanaReceiverAccount solanago.PublicKey,
	guardianSetAccount solanago.PublicKey,
	priceFeedAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PostPythPullOracleUpdateAtomic[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feedIdParam`:
		err = enc__.Encode(feedIdParam)
		if err != nil {
			return nil, errors.NewField("feedIdParam", err)
		}
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "keeper": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, true, true))
		// Account 1 "pyth_solana_receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(pythSolanaReceiverAccount, false, false))
		// Account 2 "guardian_set": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(guardianSetAccount, false, false))
		// Account 3 "price_feed": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(priceFeedAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "post_multi_pyth_pull_oracle_updates_atomic" instruction.
func NewPostMultiPythPullOracleUpdatesAtomicInstruction(
	// Params:
	paramsParam []byte,

	// Accounts:
	keeperAccount solanago.PublicKey,
	pythSolanaReceiverAccount solanago.PublicKey,
	guardianSetAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PostMultiPythPullOracleUpdatesAtomic[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "keeper": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, true, true))
		// Account 1 "pyth_solana_receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(pythSolanaReceiverAccount, false, false))
		// Account 2 "guardian_set": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(guardianSetAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause_spot_market_deposit_withdraw" instruction.
func NewPauseSpotMarketDepositWithdrawInstruction(
	stateAccount solanago.PublicKey,
	keeperAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "keeper": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, false, true))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 3 "spot_market_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	quoteAssetMintAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "quote_asset_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(quoteAssetMintAccount, false, false))
		// Account 3 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 4 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_spot_market" instruction.
func NewInitializeSpotMarketInstruction(
	// Params:
	optimalUtilizationParam uint32,
	optimalBorrowRateParam uint32,
	maxBorrowRateParam uint32,
	oracleSourceParam OracleSource,
	initialAssetWeightParam uint32,
	maintenanceAssetWeightParam uint32,
	initialLiabilityWeightParam uint32,
	maintenanceLiabilityWeightParam uint32,
	imfFactorParam uint32,
	liquidatorFeeParam uint32,
	ifLiquidationFeeParam uint32,
	activeStatusParam bool,
	assetTierParam AssetTier,
	scaleInitialAssetWeightStartParam uint64,
	withdrawGuardThresholdParam uint64,
	orderTickSizeParam uint64,
	orderStepSizeParam uint64,
	ifTotalFactorParam uint32,
	nameParam [32]uint8,

	// Accounts:
	spotMarketAccount solanago.PublicKey,
	spotMarketMintAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeSpotMarket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `optimalUtilizationParam`:
		err = enc__.Encode(optimalUtilizationParam)
		if err != nil {
			return nil, errors.NewField("optimalUtilizationParam", err)
		}
		// Serialize `optimalBorrowRateParam`:
		err = enc__.Encode(optimalBorrowRateParam)
		if err != nil {
			return nil, errors.NewField("optimalBorrowRateParam", err)
		}
		// Serialize `maxBorrowRateParam`:
		err = enc__.Encode(maxBorrowRateParam)
		if err != nil {
			return nil, errors.NewField("maxBorrowRateParam", err)
		}
		// Serialize `oracleSourceParam`:
		err = enc__.Encode(oracleSourceParam)
		if err != nil {
			return nil, errors.NewField("oracleSourceParam", err)
		}
		// Serialize `initialAssetWeightParam`:
		err = enc__.Encode(initialAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("initialAssetWeightParam", err)
		}
		// Serialize `maintenanceAssetWeightParam`:
		err = enc__.Encode(maintenanceAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("maintenanceAssetWeightParam", err)
		}
		// Serialize `initialLiabilityWeightParam`:
		err = enc__.Encode(initialLiabilityWeightParam)
		if err != nil {
			return nil, errors.NewField("initialLiabilityWeightParam", err)
		}
		// Serialize `maintenanceLiabilityWeightParam`:
		err = enc__.Encode(maintenanceLiabilityWeightParam)
		if err != nil {
			return nil, errors.NewField("maintenanceLiabilityWeightParam", err)
		}
		// Serialize `imfFactorParam`:
		err = enc__.Encode(imfFactorParam)
		if err != nil {
			return nil, errors.NewField("imfFactorParam", err)
		}
		// Serialize `liquidatorFeeParam`:
		err = enc__.Encode(liquidatorFeeParam)
		if err != nil {
			return nil, errors.NewField("liquidatorFeeParam", err)
		}
		// Serialize `ifLiquidationFeeParam`:
		err = enc__.Encode(ifLiquidationFeeParam)
		if err != nil {
			return nil, errors.NewField("ifLiquidationFeeParam", err)
		}
		// Serialize `activeStatusParam`:
		err = enc__.Encode(activeStatusParam)
		if err != nil {
			return nil, errors.NewField("activeStatusParam", err)
		}
		// Serialize `assetTierParam`:
		err = enc__.Encode(assetTierParam)
		if err != nil {
			return nil, errors.NewField("assetTierParam", err)
		}
		// Serialize `scaleInitialAssetWeightStartParam`:
		err = enc__.Encode(scaleInitialAssetWeightStartParam)
		if err != nil {
			return nil, errors.NewField("scaleInitialAssetWeightStartParam", err)
		}
		// Serialize `withdrawGuardThresholdParam`:
		err = enc__.Encode(withdrawGuardThresholdParam)
		if err != nil {
			return nil, errors.NewField("withdrawGuardThresholdParam", err)
		}
		// Serialize `orderTickSizeParam`:
		err = enc__.Encode(orderTickSizeParam)
		if err != nil {
			return nil, errors.NewField("orderTickSizeParam", err)
		}
		// Serialize `orderStepSizeParam`:
		err = enc__.Encode(orderStepSizeParam)
		if err != nil {
			return nil, errors.NewField("orderStepSizeParam", err)
		}
		// Serialize `ifTotalFactorParam`:
		err = enc__.Encode(ifTotalFactorParam)
		if err != nil {
			return nil, errors.NewField("ifTotalFactorParam", err)
		}
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 1 "spot_market_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketMintAccount, false, false))
		// Account 2 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 3 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 4 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 5 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 6 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 7 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 8 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 10 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_initialized_spot_market" instruction.
func NewDeleteInitializedSpotMarketInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	insuranceFundVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeleteInitializedSpotMarket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 3 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 4 "insurance_fund_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(insuranceFundVaultAccount, true, false))
		// Account 5 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_serum_fulfillment_config" instruction.
func NewInitializeSerumFulfillmentConfigInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	baseSpotMarketAccount solanago.PublicKey,
	quoteSpotMarketAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	serumProgramAccount solanago.PublicKey,
	serumMarketAccount solanago.PublicKey,
	serumOpenOrdersAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	serumFulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeSerumFulfillmentConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseSpotMarketAccount, false, false))
		// Account 1 "quote_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(quoteSpotMarketAccount, false, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "serum_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(serumProgramAccount, false, false))
		// Account 4 "serum_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(serumMarketAccount, false, false))
		// Account 5 "serum_open_orders": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(serumOpenOrdersAccount, true, false))
		// Account 6 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 7 "serum_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(serumFulfillmentConfigAccount, true, false))
		// Account 8 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 9 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_serum_fulfillment_config_status" instruction.
func NewUpdateSerumFulfillmentConfigStatusInstruction(
	// Params:
	statusParam SpotFulfillmentConfigStatus,

	// Accounts:
	stateAccount solanago.PublicKey,
	serumFulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSerumFulfillmentConfigStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "serum_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(serumFulfillmentConfigAccount, true, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_openbook_v2_fulfillment_config" instruction.
func NewInitializeOpenbookV2FulfillmentConfigInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	baseSpotMarketAccount solanago.PublicKey,
	quoteSpotMarketAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	openbookV2ProgramAccount solanago.PublicKey,
	openbookV2MarketAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	openbookV2FulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeOpenbookV2FulfillmentConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseSpotMarketAccount, false, false))
		// Account 1 "quote_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(quoteSpotMarketAccount, false, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "openbook_v2_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(openbookV2ProgramAccount, false, false))
		// Account 4 "openbook_v2_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(openbookV2MarketAccount, false, false))
		// Account 5 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 6 "openbook_v2_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(openbookV2FulfillmentConfigAccount, true, false))
		// Account 7 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 8 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "openbook_v2_fulfillment_config_status" instruction.
func NewOpenbookV2FulfillmentConfigStatusInstruction(
	// Params:
	statusParam SpotFulfillmentConfigStatus,

	// Accounts:
	stateAccount solanago.PublicKey,
	openbookV2FulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OpenbookV2FulfillmentConfigStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "openbook_v2_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(openbookV2FulfillmentConfigAccount, true, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_phoenix_fulfillment_config" instruction.
func NewInitializePhoenixFulfillmentConfigInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	baseSpotMarketAccount solanago.PublicKey,
	quoteSpotMarketAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	phoenixProgramAccount solanago.PublicKey,
	phoenixMarketAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	phoenixFulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePhoenixFulfillmentConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "base_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(baseSpotMarketAccount, false, false))
		// Account 1 "quote_spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(quoteSpotMarketAccount, false, false))
		// Account 2 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "phoenix_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(phoenixProgramAccount, false, false))
		// Account 4 "phoenix_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(phoenixMarketAccount, false, false))
		// Account 5 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 6 "phoenix_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(phoenixFulfillmentConfigAccount, true, false))
		// Account 7 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 8 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "phoenix_fulfillment_config_status" instruction.
func NewPhoenixFulfillmentConfigStatusInstruction(
	// Params:
	statusParam SpotFulfillmentConfigStatus,

	// Accounts:
	stateAccount solanago.PublicKey,
	phoenixFulfillmentConfigAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PhoenixFulfillmentConfigStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "phoenix_fulfillment_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(phoenixFulfillmentConfigAccount, true, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_serum_vault" instruction.
func NewUpdateSerumVaultInstruction(
	stateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	srmVaultAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 2 "srm_vault": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(srmVaultAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_perp_market" instruction.
func NewInitializePerpMarketInstruction(
	// Params:
	marketIndexParam uint16,
	ammBaseAssetReserveParam binary.Uint128,
	ammQuoteAssetReserveParam binary.Uint128,
	ammPeriodicityParam int64,
	ammPegMultiplierParam binary.Uint128,
	oracleSourceParam OracleSource,
	contractTierParam ContractTier,
	marginRatioInitialParam uint32,
	marginRatioMaintenanceParam uint32,
	liquidatorFeeParam uint32,
	ifLiquidationFeeParam uint32,
	imfFactorParam uint32,
	activeStatusParam bool,
	baseSpreadParam uint32,
	maxSpreadParam uint32,
	maxOpenInterestParam binary.Uint128,
	maxRevenueWithdrawPerPeriodParam uint64,
	quoteMaxInsuranceParam uint64,
	orderStepSizeParam uint64,
	orderTickSizeParam uint64,
	minOrderSizeParam uint64,
	concentrationCoefScaleParam binary.Uint128,
	curveUpdateIntensityParam uint8,
	ammJitIntensityParam uint8,
	nameParam [32]uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePerpMarket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `ammBaseAssetReserveParam`:
		err = enc__.Encode(ammBaseAssetReserveParam)
		if err != nil {
			return nil, errors.NewField("ammBaseAssetReserveParam", err)
		}
		// Serialize `ammQuoteAssetReserveParam`:
		err = enc__.Encode(ammQuoteAssetReserveParam)
		if err != nil {
			return nil, errors.NewField("ammQuoteAssetReserveParam", err)
		}
		// Serialize `ammPeriodicityParam`:
		err = enc__.Encode(ammPeriodicityParam)
		if err != nil {
			return nil, errors.NewField("ammPeriodicityParam", err)
		}
		// Serialize `ammPegMultiplierParam`:
		err = enc__.Encode(ammPegMultiplierParam)
		if err != nil {
			return nil, errors.NewField("ammPegMultiplierParam", err)
		}
		// Serialize `oracleSourceParam`:
		err = enc__.Encode(oracleSourceParam)
		if err != nil {
			return nil, errors.NewField("oracleSourceParam", err)
		}
		// Serialize `contractTierParam`:
		err = enc__.Encode(contractTierParam)
		if err != nil {
			return nil, errors.NewField("contractTierParam", err)
		}
		// Serialize `marginRatioInitialParam`:
		err = enc__.Encode(marginRatioInitialParam)
		if err != nil {
			return nil, errors.NewField("marginRatioInitialParam", err)
		}
		// Serialize `marginRatioMaintenanceParam`:
		err = enc__.Encode(marginRatioMaintenanceParam)
		if err != nil {
			return nil, errors.NewField("marginRatioMaintenanceParam", err)
		}
		// Serialize `liquidatorFeeParam`:
		err = enc__.Encode(liquidatorFeeParam)
		if err != nil {
			return nil, errors.NewField("liquidatorFeeParam", err)
		}
		// Serialize `ifLiquidationFeeParam`:
		err = enc__.Encode(ifLiquidationFeeParam)
		if err != nil {
			return nil, errors.NewField("ifLiquidationFeeParam", err)
		}
		// Serialize `imfFactorParam`:
		err = enc__.Encode(imfFactorParam)
		if err != nil {
			return nil, errors.NewField("imfFactorParam", err)
		}
		// Serialize `activeStatusParam`:
		err = enc__.Encode(activeStatusParam)
		if err != nil {
			return nil, errors.NewField("activeStatusParam", err)
		}
		// Serialize `baseSpreadParam`:
		err = enc__.Encode(baseSpreadParam)
		if err != nil {
			return nil, errors.NewField("baseSpreadParam", err)
		}
		// Serialize `maxSpreadParam`:
		err = enc__.Encode(maxSpreadParam)
		if err != nil {
			return nil, errors.NewField("maxSpreadParam", err)
		}
		// Serialize `maxOpenInterestParam`:
		err = enc__.Encode(maxOpenInterestParam)
		if err != nil {
			return nil, errors.NewField("maxOpenInterestParam", err)
		}
		// Serialize `maxRevenueWithdrawPerPeriodParam`:
		err = enc__.Encode(maxRevenueWithdrawPerPeriodParam)
		if err != nil {
			return nil, errors.NewField("maxRevenueWithdrawPerPeriodParam", err)
		}
		// Serialize `quoteMaxInsuranceParam`:
		err = enc__.Encode(quoteMaxInsuranceParam)
		if err != nil {
			return nil, errors.NewField("quoteMaxInsuranceParam", err)
		}
		// Serialize `orderStepSizeParam`:
		err = enc__.Encode(orderStepSizeParam)
		if err != nil {
			return nil, errors.NewField("orderStepSizeParam", err)
		}
		// Serialize `orderTickSizeParam`:
		err = enc__.Encode(orderTickSizeParam)
		if err != nil {
			return nil, errors.NewField("orderTickSizeParam", err)
		}
		// Serialize `minOrderSizeParam`:
		err = enc__.Encode(minOrderSizeParam)
		if err != nil {
			return nil, errors.NewField("minOrderSizeParam", err)
		}
		// Serialize `concentrationCoefScaleParam`:
		err = enc__.Encode(concentrationCoefScaleParam)
		if err != nil {
			return nil, errors.NewField("concentrationCoefScaleParam", err)
		}
		// Serialize `curveUpdateIntensityParam`:
		err = enc__.Encode(curveUpdateIntensityParam)
		if err != nil {
			return nil, errors.NewField("curveUpdateIntensityParam", err)
		}
		// Serialize `ammJitIntensityParam`:
		err = enc__.Encode(ammJitIntensityParam)
		if err != nil {
			return nil, errors.NewField("ammJitIntensityParam", err)
		}
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 4 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_prediction_market" instruction.
func NewInitializePredictionMarketInstruction(
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "delete_initialized_perp_market" instruction.
func NewDeleteInitializedPerpMarketInstruction(
	// Params:
	marketIndexParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeleteInitializedPerpMarket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "move_amm_price" instruction.
func NewMoveAmmPriceInstruction(
	// Params:
	baseAssetReserveParam binary.Uint128,
	quoteAssetReserveParam binary.Uint128,
	sqrtKParam binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_MoveAmmPrice[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `baseAssetReserveParam`:
		err = enc__.Encode(baseAssetReserveParam)
		if err != nil {
			return nil, errors.NewField("baseAssetReserveParam", err)
		}
		// Serialize `quoteAssetReserveParam`:
		err = enc__.Encode(quoteAssetReserveParam)
		if err != nil {
			return nil, errors.NewField("quoteAssetReserveParam", err)
		}
		// Serialize `sqrtKParam`:
		err = enc__.Encode(sqrtKParam)
		if err != nil {
			return nil, errors.NewField("sqrtKParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "recenter_perp_market_amm" instruction.
func NewRecenterPerpMarketAmmInstruction(
	// Params:
	pegMultiplierParam binary.Uint128,
	sqrtKParam binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RecenterPerpMarketAmm[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pegMultiplierParam`:
		err = enc__.Encode(pegMultiplierParam)
		if err != nil {
			return nil, errors.NewField("pegMultiplierParam", err)
		}
		// Serialize `sqrtKParam`:
		err = enc__.Encode(sqrtKParam)
		if err != nil {
			return nil, errors.NewField("sqrtKParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "recenter_perp_market_amm_crank" instruction.
func NewRecenterPerpMarketAmmCrankInstruction(
	// Params:
	depthParam *binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RecenterPerpMarketAmmCrank[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `depthParam` (optional):
		{
			if depthParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("depthParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("depthParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(depthParam)
				if err != nil {
					return nil, errors.NewField("depthParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, false, false))
		// Account 4 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_amm_summary_stats" instruction.
func NewUpdatePerpMarketAmmSummaryStatsInstruction(
	// Params:
	paramsParam UpdatePerpMarketSummaryStatsParams,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketAmmSummaryStats[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "spot_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, false, false))
		// Account 4 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_expiry" instruction.
func NewUpdatePerpMarketExpiryInstruction(
	// Params:
	expiryTsParam int64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketExpiry[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `expiryTsParam`:
		err = enc__.Encode(expiryTsParam)
		if err != nil {
			return nil, errors.NewField("expiryTsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "settle_expired_market_pools_to_revenue_pool" instruction.
func NewSettleExpiredMarketPoolsToRevenuePoolInstruction(
	stateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 3 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "deposit_into_perp_market_fee_pool" instruction.
func NewDepositIntoPerpMarketFeePoolInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	sourceVaultAccount solanago.PublicKey,
	driftSignerAccount solanago.PublicKey,
	quoteSpotMarketAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositIntoPerpMarketFeePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "source_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceVaultAccount, true, false))
		// Account 4 "drift_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(driftSignerAccount, false, false))
		// Account 5 "quote_spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(quoteSpotMarketAccount, true, false))
		// Account 6 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 7 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_pnl_pool" instruction.
func NewUpdatePerpMarketPnlPoolInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketPnlPool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 3 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 4 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit_into_spot_market_vault" instruction.
func NewDepositIntoSpotMarketVaultInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	sourceVaultAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositIntoSpotMarketVault[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "source_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceVaultAccount, true, false))
		// Account 4 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit_into_spot_market_revenue_pool" instruction.
func NewDepositIntoSpotMarketRevenuePoolInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	userTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositIntoSpotMarketRevenuePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 4 "user_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userTokenAccountAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "repeg_amm_curve" instruction.
func NewRepegAmmCurveInstruction(
	// Params:
	newPegCandidateParam binary.Uint128,

	// Accounts:
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RepegAmmCurve[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newPegCandidateParam`:
		err = enc__.Encode(newPegCandidateParam)
		if err != nil {
			return nil, errors.NewField("newPegCandidateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 3 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_amm_oracle_twap" instruction.
func NewUpdatePerpMarketAmmOracleTwapInstruction(
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 3 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "reset_perp_market_amm_oracle_twap" instruction.
func NewResetPerpMarketAmmOracleTwapInstruction(
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 2 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 3 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_k" instruction.
func NewUpdateKInstruction(
	// Params:
	sqrtKParam binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateK[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sqrtKParam`:
		err = enc__.Encode(sqrtKParam)
		if err != nil {
			return nil, errors.NewField("sqrtKParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_margin_ratio" instruction.
func NewUpdatePerpMarketMarginRatioInstruction(
	// Params:
	marginRatioInitialParam uint32,
	marginRatioMaintenanceParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMarginRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marginRatioInitialParam`:
		err = enc__.Encode(marginRatioInitialParam)
		if err != nil {
			return nil, errors.NewField("marginRatioInitialParam", err)
		}
		// Serialize `marginRatioMaintenanceParam`:
		err = enc__.Encode(marginRatioMaintenanceParam)
		if err != nil {
			return nil, errors.NewField("marginRatioMaintenanceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_high_leverage_margin_ratio" instruction.
func NewUpdatePerpMarketHighLeverageMarginRatioInstruction(
	// Params:
	marginRatioInitialParam uint16,
	marginRatioMaintenanceParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketHighLeverageMarginRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marginRatioInitialParam`:
		err = enc__.Encode(marginRatioInitialParam)
		if err != nil {
			return nil, errors.NewField("marginRatioInitialParam", err)
		}
		// Serialize `marginRatioMaintenanceParam`:
		err = enc__.Encode(marginRatioMaintenanceParam)
		if err != nil {
			return nil, errors.NewField("marginRatioMaintenanceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_funding_period" instruction.
func NewUpdatePerpMarketFundingPeriodInstruction(
	// Params:
	fundingPeriodParam int64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketFundingPeriod[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fundingPeriodParam`:
		err = enc__.Encode(fundingPeriodParam)
		if err != nil {
			return nil, errors.NewField("fundingPeriodParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_max_imbalances" instruction.
func NewUpdatePerpMarketMaxImbalancesInstruction(
	// Params:
	unrealizedMaxImbalanceParam uint64,
	maxRevenueWithdrawPerPeriodParam uint64,
	quoteMaxInsuranceParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMaxImbalances[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `unrealizedMaxImbalanceParam`:
		err = enc__.Encode(unrealizedMaxImbalanceParam)
		if err != nil {
			return nil, errors.NewField("unrealizedMaxImbalanceParam", err)
		}
		// Serialize `maxRevenueWithdrawPerPeriodParam`:
		err = enc__.Encode(maxRevenueWithdrawPerPeriodParam)
		if err != nil {
			return nil, errors.NewField("maxRevenueWithdrawPerPeriodParam", err)
		}
		// Serialize `quoteMaxInsuranceParam`:
		err = enc__.Encode(quoteMaxInsuranceParam)
		if err != nil {
			return nil, errors.NewField("quoteMaxInsuranceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_liquidation_fee" instruction.
func NewUpdatePerpMarketLiquidationFeeInstruction(
	// Params:
	liquidatorFeeParam uint32,
	ifLiquidationFeeParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketLiquidationFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidatorFeeParam`:
		err = enc__.Encode(liquidatorFeeParam)
		if err != nil {
			return nil, errors.NewField("liquidatorFeeParam", err)
		}
		// Serialize `ifLiquidationFeeParam`:
		err = enc__.Encode(ifLiquidationFeeParam)
		if err != nil {
			return nil, errors.NewField("ifLiquidationFeeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_insurance_fund_unstaking_period" instruction.
func NewUpdateInsuranceFundUnstakingPeriodInstruction(
	// Params:
	insuranceFundUnstakingPeriodParam int64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateInsuranceFundUnstakingPeriod[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `insuranceFundUnstakingPeriodParam`:
		err = enc__.Encode(insuranceFundUnstakingPeriodParam)
		if err != nil {
			return nil, errors.NewField("insuranceFundUnstakingPeriodParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_pool_id" instruction.
func NewUpdateSpotMarketPoolIdInstruction(
	// Params:
	poolIdParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketPoolId[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `poolIdParam`:
		err = enc__.Encode(poolIdParam)
		if err != nil {
			return nil, errors.NewField("poolIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_liquidation_fee" instruction.
func NewUpdateSpotMarketLiquidationFeeInstruction(
	// Params:
	liquidatorFeeParam uint32,
	ifLiquidationFeeParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketLiquidationFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidatorFeeParam`:
		err = enc__.Encode(liquidatorFeeParam)
		if err != nil {
			return nil, errors.NewField("liquidatorFeeParam", err)
		}
		// Serialize `ifLiquidationFeeParam`:
		err = enc__.Encode(ifLiquidationFeeParam)
		if err != nil {
			return nil, errors.NewField("ifLiquidationFeeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_withdraw_guard_threshold" instruction.
func NewUpdateWithdrawGuardThresholdInstruction(
	// Params:
	withdrawGuardThresholdParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateWithdrawGuardThreshold[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `withdrawGuardThresholdParam`:
		err = enc__.Encode(withdrawGuardThresholdParam)
		if err != nil {
			return nil, errors.NewField("withdrawGuardThresholdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_if_factor" instruction.
func NewUpdateSpotMarketIfFactorInstruction(
	// Params:
	spotMarketIndexParam uint16,
	userIfFactorParam uint32,
	totalIfFactorParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketIfFactor[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `spotMarketIndexParam`:
		err = enc__.Encode(spotMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("spotMarketIndexParam", err)
		}
		// Serialize `userIfFactorParam`:
		err = enc__.Encode(userIfFactorParam)
		if err != nil {
			return nil, errors.NewField("userIfFactorParam", err)
		}
		// Serialize `totalIfFactorParam`:
		err = enc__.Encode(totalIfFactorParam)
		if err != nil {
			return nil, errors.NewField("totalIfFactorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_revenue_settle_period" instruction.
func NewUpdateSpotMarketRevenueSettlePeriodInstruction(
	// Params:
	revenueSettlePeriodParam int64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketRevenueSettlePeriod[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `revenueSettlePeriodParam`:
		err = enc__.Encode(revenueSettlePeriodParam)
		if err != nil {
			return nil, errors.NewField("revenueSettlePeriodParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_status" instruction.
func NewUpdateSpotMarketStatusInstruction(
	// Params:
	statusParam MarketStatus,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_paused_operations" instruction.
func NewUpdateSpotMarketPausedOperationsInstruction(
	// Params:
	pausedOperationsParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketPausedOperations[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pausedOperationsParam`:
		err = enc__.Encode(pausedOperationsParam)
		if err != nil {
			return nil, errors.NewField("pausedOperationsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_asset_tier" instruction.
func NewUpdateSpotMarketAssetTierInstruction(
	// Params:
	assetTierParam AssetTier,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketAssetTier[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `assetTierParam`:
		err = enc__.Encode(assetTierParam)
		if err != nil {
			return nil, errors.NewField("assetTierParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_margin_weights" instruction.
func NewUpdateSpotMarketMarginWeightsInstruction(
	// Params:
	initialAssetWeightParam uint32,
	maintenanceAssetWeightParam uint32,
	initialLiabilityWeightParam uint32,
	maintenanceLiabilityWeightParam uint32,
	imfFactorParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketMarginWeights[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `initialAssetWeightParam`:
		err = enc__.Encode(initialAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("initialAssetWeightParam", err)
		}
		// Serialize `maintenanceAssetWeightParam`:
		err = enc__.Encode(maintenanceAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("maintenanceAssetWeightParam", err)
		}
		// Serialize `initialLiabilityWeightParam`:
		err = enc__.Encode(initialLiabilityWeightParam)
		if err != nil {
			return nil, errors.NewField("initialLiabilityWeightParam", err)
		}
		// Serialize `maintenanceLiabilityWeightParam`:
		err = enc__.Encode(maintenanceLiabilityWeightParam)
		if err != nil {
			return nil, errors.NewField("maintenanceLiabilityWeightParam", err)
		}
		// Serialize `imfFactorParam`:
		err = enc__.Encode(imfFactorParam)
		if err != nil {
			return nil, errors.NewField("imfFactorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_borrow_rate" instruction.
func NewUpdateSpotMarketBorrowRateInstruction(
	// Params:
	optimalUtilizationParam uint32,
	optimalBorrowRateParam uint32,
	maxBorrowRateParam uint32,
	minBorrowRateParam *uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketBorrowRate[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `optimalUtilizationParam`:
		err = enc__.Encode(optimalUtilizationParam)
		if err != nil {
			return nil, errors.NewField("optimalUtilizationParam", err)
		}
		// Serialize `optimalBorrowRateParam`:
		err = enc__.Encode(optimalBorrowRateParam)
		if err != nil {
			return nil, errors.NewField("optimalBorrowRateParam", err)
		}
		// Serialize `maxBorrowRateParam`:
		err = enc__.Encode(maxBorrowRateParam)
		if err != nil {
			return nil, errors.NewField("maxBorrowRateParam", err)
		}
		// Serialize `minBorrowRateParam` (optional):
		{
			if minBorrowRateParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("minBorrowRateParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("minBorrowRateParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(minBorrowRateParam)
				if err != nil {
					return nil, errors.NewField("minBorrowRateParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_max_token_deposits" instruction.
func NewUpdateSpotMarketMaxTokenDepositsInstruction(
	// Params:
	maxTokenDepositsParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketMaxTokenDeposits[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxTokenDepositsParam`:
		err = enc__.Encode(maxTokenDepositsParam)
		if err != nil {
			return nil, errors.NewField("maxTokenDepositsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_max_token_borrows" instruction.
func NewUpdateSpotMarketMaxTokenBorrowsInstruction(
	// Params:
	maxTokenBorrowsFractionParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketMaxTokenBorrows[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxTokenBorrowsFractionParam`:
		err = enc__.Encode(maxTokenBorrowsFractionParam)
		if err != nil {
			return nil, errors.NewField("maxTokenBorrowsFractionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_scale_initial_asset_weight_start" instruction.
func NewUpdateSpotMarketScaleInitialAssetWeightStartInstruction(
	// Params:
	scaleInitialAssetWeightStartParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketScaleInitialAssetWeightStart[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `scaleInitialAssetWeightStartParam`:
		err = enc__.Encode(scaleInitialAssetWeightStartParam)
		if err != nil {
			return nil, errors.NewField("scaleInitialAssetWeightStartParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_oracle" instruction.
func NewUpdateSpotMarketOracleInstruction(
	// Params:
	oracleParam solanago.PublicKey,
	oracleSourceParam OracleSource,
	skipInvariantCheckParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	oldOracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `oracleParam`:
		err = enc__.Encode(oracleParam)
		if err != nil {
			return nil, errors.NewField("oracleParam", err)
		}
		// Serialize `oracleSourceParam`:
		err = enc__.Encode(oracleSourceParam)
		if err != nil {
			return nil, errors.NewField("oracleSourceParam", err)
		}
		// Serialize `skipInvariantCheckParam`:
		err = enc__.Encode(skipInvariantCheckParam)
		if err != nil {
			return nil, errors.NewField("skipInvariantCheckParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
		// Account 3 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 4 "old_oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oldOracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_step_size_and_tick_size" instruction.
func NewUpdateSpotMarketStepSizeAndTickSizeInstruction(
	// Params:
	stepSizeParam uint64,
	tickSizeParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketStepSizeAndTickSize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `stepSizeParam`:
		err = enc__.Encode(stepSizeParam)
		if err != nil {
			return nil, errors.NewField("stepSizeParam", err)
		}
		// Serialize `tickSizeParam`:
		err = enc__.Encode(tickSizeParam)
		if err != nil {
			return nil, errors.NewField("tickSizeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_min_order_size" instruction.
func NewUpdateSpotMarketMinOrderSizeInstruction(
	// Params:
	orderSizeParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketMinOrderSize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderSizeParam`:
		err = enc__.Encode(orderSizeParam)
		if err != nil {
			return nil, errors.NewField("orderSizeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_orders_enabled" instruction.
func NewUpdateSpotMarketOrdersEnabledInstruction(
	// Params:
	ordersEnabledParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketOrdersEnabled[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ordersEnabledParam`:
		err = enc__.Encode(ordersEnabledParam)
		if err != nil {
			return nil, errors.NewField("ordersEnabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_if_paused_operations" instruction.
func NewUpdateSpotMarketIfPausedOperationsInstruction(
	// Params:
	pausedOperationsParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketIfPausedOperations[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pausedOperationsParam`:
		err = enc__.Encode(pausedOperationsParam)
		if err != nil {
			return nil, errors.NewField("pausedOperationsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_name" instruction.
func NewUpdateSpotMarketNameInstruction(
	// Params:
	nameParam [32]uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketName[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_status" instruction.
func NewUpdatePerpMarketStatusInstruction(
	// Params:
	statusParam MarketStatus,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_paused_operations" instruction.
func NewUpdatePerpMarketPausedOperationsInstruction(
	// Params:
	pausedOperationsParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketPausedOperations[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pausedOperationsParam`:
		err = enc__.Encode(pausedOperationsParam)
		if err != nil {
			return nil, errors.NewField("pausedOperationsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_contract_tier" instruction.
func NewUpdatePerpMarketContractTierInstruction(
	// Params:
	contractTierParam ContractTier,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketContractTier[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `contractTierParam`:
		err = enc__.Encode(contractTierParam)
		if err != nil {
			return nil, errors.NewField("contractTierParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_imf_factor" instruction.
func NewUpdatePerpMarketImfFactorInstruction(
	// Params:
	imfFactorParam uint32,
	unrealizedPnlImfFactorParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketImfFactor[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `imfFactorParam`:
		err = enc__.Encode(imfFactorParam)
		if err != nil {
			return nil, errors.NewField("imfFactorParam", err)
		}
		// Serialize `unrealizedPnlImfFactorParam`:
		err = enc__.Encode(unrealizedPnlImfFactorParam)
		if err != nil {
			return nil, errors.NewField("unrealizedPnlImfFactorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_unrealized_asset_weight" instruction.
func NewUpdatePerpMarketUnrealizedAssetWeightInstruction(
	// Params:
	unrealizedInitialAssetWeightParam uint32,
	unrealizedMaintenanceAssetWeightParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketUnrealizedAssetWeight[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `unrealizedInitialAssetWeightParam`:
		err = enc__.Encode(unrealizedInitialAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("unrealizedInitialAssetWeightParam", err)
		}
		// Serialize `unrealizedMaintenanceAssetWeightParam`:
		err = enc__.Encode(unrealizedMaintenanceAssetWeightParam)
		if err != nil {
			return nil, errors.NewField("unrealizedMaintenanceAssetWeightParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_concentration_coef" instruction.
func NewUpdatePerpMarketConcentrationCoefInstruction(
	// Params:
	concentrationScaleParam binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketConcentrationCoef[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `concentrationScaleParam`:
		err = enc__.Encode(concentrationScaleParam)
		if err != nil {
			return nil, errors.NewField("concentrationScaleParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_curve_update_intensity" instruction.
func NewUpdatePerpMarketCurveUpdateIntensityInstruction(
	// Params:
	curveUpdateIntensityParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketCurveUpdateIntensity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `curveUpdateIntensityParam`:
		err = enc__.Encode(curveUpdateIntensityParam)
		if err != nil {
			return nil, errors.NewField("curveUpdateIntensityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_lp_cooldown_time" instruction.
func NewUpdateLpCooldownTimeInstruction(
	// Params:
	lpCooldownTimeParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateLpCooldownTime[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lpCooldownTimeParam`:
		err = enc__.Encode(lpCooldownTimeParam)
		if err != nil {
			return nil, errors.NewField("lpCooldownTimeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_fee_structure" instruction.
func NewUpdatePerpFeeStructureInstruction(
	// Params:
	feeStructureParam FeeStructure,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpFeeStructure[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeStructureParam`:
		err = enc__.Encode(feeStructureParam)
		if err != nil {
			return nil, errors.NewField("feeStructureParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_fee_structure" instruction.
func NewUpdateSpotFeeStructureInstruction(
	// Params:
	feeStructureParam FeeStructure,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotFeeStructure[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeStructureParam`:
		err = enc__.Encode(feeStructureParam)
		if err != nil {
			return nil, errors.NewField("feeStructureParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_initial_pct_to_liquidate" instruction.
func NewUpdateInitialPctToLiquidateInstruction(
	// Params:
	initialPctToLiquidateParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateInitialPctToLiquidate[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `initialPctToLiquidateParam`:
		err = enc__.Encode(initialPctToLiquidateParam)
		if err != nil {
			return nil, errors.NewField("initialPctToLiquidateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_liquidation_duration" instruction.
func NewUpdateLiquidationDurationInstruction(
	// Params:
	liquidationDurationParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateLiquidationDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidationDurationParam`:
		err = enc__.Encode(liquidationDurationParam)
		if err != nil {
			return nil, errors.NewField("liquidationDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_liquidation_margin_buffer_ratio" instruction.
func NewUpdateLiquidationMarginBufferRatioInstruction(
	// Params:
	liquidationMarginBufferRatioParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateLiquidationMarginBufferRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidationMarginBufferRatioParam`:
		err = enc__.Encode(liquidationMarginBufferRatioParam)
		if err != nil {
			return nil, errors.NewField("liquidationMarginBufferRatioParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_oracle_guard_rails" instruction.
func NewUpdateOracleGuardRailsInstruction(
	// Params:
	oracleGuardRailsParam OracleGuardRails,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateOracleGuardRails[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `oracleGuardRailsParam`:
		err = enc__.Encode(oracleGuardRailsParam)
		if err != nil {
			return nil, errors.NewField("oracleGuardRailsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_state_settlement_duration" instruction.
func NewUpdateStateSettlementDurationInstruction(
	// Params:
	settlementDurationParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateStateSettlementDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `settlementDurationParam`:
		err = enc__.Encode(settlementDurationParam)
		if err != nil {
			return nil, errors.NewField("settlementDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_state_max_number_of_sub_accounts" instruction.
func NewUpdateStateMaxNumberOfSubAccountsInstruction(
	// Params:
	maxNumberOfSubAccountsParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateStateMaxNumberOfSubAccounts[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxNumberOfSubAccountsParam`:
		err = enc__.Encode(maxNumberOfSubAccountsParam)
		if err != nil {
			return nil, errors.NewField("maxNumberOfSubAccountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_state_max_initialize_user_fee" instruction.
func NewUpdateStateMaxInitializeUserFeeInstruction(
	// Params:
	maxInitializeUserFeeParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateStateMaxInitializeUserFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxInitializeUserFeeParam`:
		err = enc__.Encode(maxInitializeUserFeeParam)
		if err != nil {
			return nil, errors.NewField("maxInitializeUserFeeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_oracle" instruction.
func NewUpdatePerpMarketOracleInstruction(
	// Params:
	oracleParam solanago.PublicKey,
	oracleSourceParam OracleSource,
	skipInvariantCheckParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	oracleAccount solanago.PublicKey,
	oldOracleAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `oracleParam`:
		err = enc__.Encode(oracleParam)
		if err != nil {
			return nil, errors.NewField("oracleParam", err)
		}
		// Serialize `oracleSourceParam`:
		err = enc__.Encode(oracleSourceParam)
		if err != nil {
			return nil, errors.NewField("oracleSourceParam", err)
		}
		// Serialize `skipInvariantCheckParam`:
		err = enc__.Encode(skipInvariantCheckParam)
		if err != nil {
			return nil, errors.NewField("skipInvariantCheckParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oracleAccount, false, false))
		// Account 4 "old_oracle": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(oldOracleAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_base_spread" instruction.
func NewUpdatePerpMarketBaseSpreadInstruction(
	// Params:
	baseSpreadParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketBaseSpread[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `baseSpreadParam`:
		err = enc__.Encode(baseSpreadParam)
		if err != nil {
			return nil, errors.NewField("baseSpreadParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_amm_jit_intensity" instruction.
func NewUpdateAmmJitIntensityInstruction(
	// Params:
	ammJitIntensityParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAmmJitIntensity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ammJitIntensityParam`:
		err = enc__.Encode(ammJitIntensityParam)
		if err != nil {
			return nil, errors.NewField("ammJitIntensityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_max_spread" instruction.
func NewUpdatePerpMarketMaxSpreadInstruction(
	// Params:
	maxSpreadParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMaxSpread[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxSpreadParam`:
		err = enc__.Encode(maxSpreadParam)
		if err != nil {
			return nil, errors.NewField("maxSpreadParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_step_size_and_tick_size" instruction.
func NewUpdatePerpMarketStepSizeAndTickSizeInstruction(
	// Params:
	stepSizeParam uint64,
	tickSizeParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketStepSizeAndTickSize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `stepSizeParam`:
		err = enc__.Encode(stepSizeParam)
		if err != nil {
			return nil, errors.NewField("stepSizeParam", err)
		}
		// Serialize `tickSizeParam`:
		err = enc__.Encode(tickSizeParam)
		if err != nil {
			return nil, errors.NewField("tickSizeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_name" instruction.
func NewUpdatePerpMarketNameInstruction(
	// Params:
	nameParam [32]uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketName[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `nameParam`:
		err = enc__.Encode(nameParam)
		if err != nil {
			return nil, errors.NewField("nameParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_min_order_size" instruction.
func NewUpdatePerpMarketMinOrderSizeInstruction(
	// Params:
	orderSizeParam uint64,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMinOrderSize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `orderSizeParam`:
		err = enc__.Encode(orderSizeParam)
		if err != nil {
			return nil, errors.NewField("orderSizeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_max_slippage_ratio" instruction.
func NewUpdatePerpMarketMaxSlippageRatioInstruction(
	// Params:
	maxSlippageRatioParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMaxSlippageRatio[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxSlippageRatioParam`:
		err = enc__.Encode(maxSlippageRatioParam)
		if err != nil {
			return nil, errors.NewField("maxSlippageRatioParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_max_fill_reserve_fraction" instruction.
func NewUpdatePerpMarketMaxFillReserveFractionInstruction(
	// Params:
	maxFillReserveFractionParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMaxFillReserveFraction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxFillReserveFractionParam`:
		err = enc__.Encode(maxFillReserveFractionParam)
		if err != nil {
			return nil, errors.NewField("maxFillReserveFractionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_max_open_interest" instruction.
func NewUpdatePerpMarketMaxOpenInterestInstruction(
	// Params:
	maxOpenInterestParam binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketMaxOpenInterest[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxOpenInterestParam`:
		err = enc__.Encode(maxOpenInterestParam)
		if err != nil {
			return nil, errors.NewField("maxOpenInterestParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_number_of_users" instruction.
func NewUpdatePerpMarketNumberOfUsersInstruction(
	// Params:
	numberOfUsersParam *uint32,
	numberOfUsersWithBaseParam *uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketNumberOfUsers[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `numberOfUsersParam` (optional):
		{
			if numberOfUsersParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("numberOfUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("numberOfUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(numberOfUsersParam)
				if err != nil {
					return nil, errors.NewField("numberOfUsersParam", err)
				}
			}
		}
		// Serialize `numberOfUsersWithBaseParam` (optional):
		{
			if numberOfUsersWithBaseParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("numberOfUsersWithBaseParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("numberOfUsersWithBaseParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(numberOfUsersWithBaseParam)
				if err != nil {
					return nil, errors.NewField("numberOfUsersWithBaseParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_fee_adjustment" instruction.
func NewUpdatePerpMarketFeeAdjustmentInstruction(
	// Params:
	feeAdjustmentParam int16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketFeeAdjustment[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeAdjustmentParam`:
		err = enc__.Encode(feeAdjustmentParam)
		if err != nil {
			return nil, errors.NewField("feeAdjustmentParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_fee_adjustment" instruction.
func NewUpdateSpotMarketFeeAdjustmentInstruction(
	// Params:
	feeAdjustmentParam int16,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketFeeAdjustment[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeAdjustmentParam`:
		err = enc__.Encode(feeAdjustmentParam)
		if err != nil {
			return nil, errors.NewField("feeAdjustmentParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_fuel" instruction.
func NewUpdatePerpMarketFuelInstruction(
	// Params:
	fuelBoostTakerParam *uint8,
	fuelBoostMakerParam *uint8,
	fuelBoostPositionParam *uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketFuel[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fuelBoostTakerParam` (optional):
		{
			if fuelBoostTakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostTakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostTakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostMakerParam` (optional):
		{
			if fuelBoostMakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostMakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostMakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostPositionParam` (optional):
		{
			if fuelBoostPositionParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostPositionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostPositionParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostPositionParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostPositionParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_protected_maker_params" instruction.
func NewUpdatePerpMarketProtectedMakerParamsInstruction(
	// Params:
	protectedMakerLimitPriceDivisorParam *uint8,
	protectedMakerDynamicDivisorParam *uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketProtectedMakerParams[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `protectedMakerLimitPriceDivisorParam` (optional):
		{
			if protectedMakerLimitPriceDivisorParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("protectedMakerLimitPriceDivisorParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("protectedMakerLimitPriceDivisorParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(protectedMakerLimitPriceDivisorParam)
				if err != nil {
					return nil, errors.NewField("protectedMakerLimitPriceDivisorParam", err)
				}
			}
		}
		// Serialize `protectedMakerDynamicDivisorParam` (optional):
		{
			if protectedMakerDynamicDivisorParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("protectedMakerDynamicDivisorParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("protectedMakerDynamicDivisorParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(protectedMakerDynamicDivisorParam)
				if err != nil {
					return nil, errors.NewField("protectedMakerDynamicDivisorParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_taker_speed_bump_override" instruction.
func NewUpdatePerpMarketTakerSpeedBumpOverrideInstruction(
	// Params:
	takerSpeedBumpOverrideParam int8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketTakerSpeedBumpOverride[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `takerSpeedBumpOverrideParam`:
		err = enc__.Encode(takerSpeedBumpOverrideParam)
		if err != nil {
			return nil, errors.NewField("takerSpeedBumpOverrideParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_amm_spread_adjustment" instruction.
func NewUpdatePerpMarketAmmSpreadAdjustmentInstruction(
	// Params:
	ammSpreadAdjustmentParam int8,
	ammInventorySpreadAdjustmentParam int8,
	referencePriceOffsetParam int32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketAmmSpreadAdjustment[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `ammSpreadAdjustmentParam`:
		err = enc__.Encode(ammSpreadAdjustmentParam)
		if err != nil {
			return nil, errors.NewField("ammSpreadAdjustmentParam", err)
		}
		// Serialize `ammInventorySpreadAdjustmentParam`:
		err = enc__.Encode(ammInventorySpreadAdjustmentParam)
		if err != nil {
			return nil, errors.NewField("ammInventorySpreadAdjustmentParam", err)
		}
		// Serialize `referencePriceOffsetParam`:
		err = enc__.Encode(referencePriceOffsetParam)
		if err != nil {
			return nil, errors.NewField("referencePriceOffsetParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_market_oracle_slot_delay_override" instruction.
func NewUpdatePerpMarketOracleSlotDelayOverrideInstruction(
	// Params:
	oracleSlotDelayOverrideParam int8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpMarketOracleSlotDelayOverride[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `oracleSlotDelayOverrideParam`:
		err = enc__.Encode(oracleSlotDelayOverrideParam)
		if err != nil {
			return nil, errors.NewField("oracleSlotDelayOverrideParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_market_fuel" instruction.
func NewUpdateSpotMarketFuelInstruction(
	// Params:
	fuelBoostDepositsParam *uint8,
	fuelBoostBorrowsParam *uint8,
	fuelBoostTakerParam *uint8,
	fuelBoostMakerParam *uint8,
	fuelBoostInsuranceParam *uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	spotMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotMarketFuel[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fuelBoostDepositsParam` (optional):
		{
			if fuelBoostDepositsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostDepositsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostDepositsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostDepositsParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostDepositsParam", err)
				}
			}
		}
		// Serialize `fuelBoostBorrowsParam` (optional):
		{
			if fuelBoostBorrowsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostBorrowsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostBorrowsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostBorrowsParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostBorrowsParam", err)
				}
			}
		}
		// Serialize `fuelBoostTakerParam` (optional):
		{
			if fuelBoostTakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostTakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostTakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostMakerParam` (optional):
		{
			if fuelBoostMakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostMakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostMakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostInsuranceParam` (optional):
		{
			if fuelBoostInsuranceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostInsuranceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostInsuranceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostInsuranceParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostInsuranceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "spot_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_user_fuel" instruction.
func NewInitUserFuelInstruction(
	// Params:
	fuelBoostDepositsParam *int32,
	fuelBoostBorrowsParam *uint32,
	fuelBoostTakerParam *uint32,
	fuelBoostMakerParam *uint32,
	fuelBoostInsuranceParam *uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	userStatsAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitUserFuel[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fuelBoostDepositsParam` (optional):
		{
			if fuelBoostDepositsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostDepositsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostDepositsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostDepositsParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostDepositsParam", err)
				}
			}
		}
		// Serialize `fuelBoostBorrowsParam` (optional):
		{
			if fuelBoostBorrowsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostBorrowsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostBorrowsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostBorrowsParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostBorrowsParam", err)
				}
			}
		}
		// Serialize `fuelBoostTakerParam` (optional):
		{
			if fuelBoostTakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostTakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostTakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostTakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostMakerParam` (optional):
		{
			if fuelBoostMakerParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostMakerParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostMakerParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostMakerParam", err)
				}
			}
		}
		// Serialize `fuelBoostInsuranceParam` (optional):
		{
			if fuelBoostInsuranceParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("fuelBoostInsuranceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("fuelBoostInsuranceParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(fuelBoostInsuranceParam)
				if err != nil {
					return nil, errors.NewField("fuelBoostInsuranceParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 3 "user_stats": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userStatsAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_admin" instruction.
func NewUpdateAdminInstruction(
	// Params:
	adminParam solanago.PublicKey,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `adminParam`:
		err = enc__.Encode(adminParam)
		if err != nil {
			return nil, errors.NewField("adminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_whitelist_mint" instruction.
func NewUpdateWhitelistMintInstruction(
	// Params:
	whitelistMintParam solanago.PublicKey,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateWhitelistMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `whitelistMintParam`:
		err = enc__.Encode(whitelistMintParam)
		if err != nil {
			return nil, errors.NewField("whitelistMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_discount_mint" instruction.
func NewUpdateDiscountMintInstruction(
	// Params:
	discountMintParam solanago.PublicKey,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDiscountMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `discountMintParam`:
		err = enc__.Encode(discountMintParam)
		if err != nil {
			return nil, errors.NewField("discountMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_exchange_status" instruction.
func NewUpdateExchangeStatusInstruction(
	// Params:
	exchangeStatusParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateExchangeStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `exchangeStatusParam`:
		err = enc__.Encode(exchangeStatusParam)
		if err != nil {
			return nil, errors.NewField("exchangeStatusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_perp_auction_duration" instruction.
func NewUpdatePerpAuctionDurationInstruction(
	// Params:
	minPerpAuctionDurationParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePerpAuctionDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `minPerpAuctionDurationParam`:
		err = enc__.Encode(minPerpAuctionDurationParam)
		if err != nil {
			return nil, errors.NewField("minPerpAuctionDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_spot_auction_duration" instruction.
func NewUpdateSpotAuctionDurationInstruction(
	// Params:
	defaultSpotAuctionDurationParam uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSpotAuctionDuration[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `defaultSpotAuctionDurationParam`:
		err = enc__.Encode(defaultSpotAuctionDurationParam)
		if err != nil {
			return nil, errors.NewField("defaultSpotAuctionDurationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_protocol_if_shares_transfer_config" instruction.
func NewInitializeProtocolIfSharesTransferConfigInstruction(
	adminAccount solanago.PublicKey,
	protocolIfSharesTransferConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "protocol_if_shares_transfer_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolIfSharesTransferConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_protocol_if_shares_transfer_config" instruction.
func NewUpdateProtocolIfSharesTransferConfigInstruction(
	// Params:
	whitelistedSignersParam *[4]solanago.PublicKey,
	maxTransferPerEpochParam *binary.Uint128,

	// Accounts:
	adminAccount solanago.PublicKey,
	protocolIfSharesTransferConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateProtocolIfSharesTransferConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `whitelistedSignersParam` (optional):
		{
			if whitelistedSignersParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("whitelistedSignersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("whitelistedSignersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(whitelistedSignersParam)
				if err != nil {
					return nil, errors.NewField("whitelistedSignersParam", err)
				}
			}
		}
		// Serialize `maxTransferPerEpochParam` (optional):
		{
			if maxTransferPerEpochParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("maxTransferPerEpochParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("maxTransferPerEpochParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(maxTransferPerEpochParam)
				if err != nil {
					return nil, errors.NewField("maxTransferPerEpochParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "protocol_if_shares_transfer_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolIfSharesTransferConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_prelaunch_oracle" instruction.
func NewInitializePrelaunchOracleInstruction(
	// Params:
	paramsParam PrelaunchOracleParams,

	// Accounts:
	adminAccount solanago.PublicKey,
	prelaunchOracleAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePrelaunchOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "prelaunch_oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(prelaunchOracleAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_prelaunch_oracle_params" instruction.
func NewUpdatePrelaunchOracleParamsInstruction(
	// Params:
	paramsParam PrelaunchOracleParams,

	// Accounts:
	adminAccount solanago.PublicKey,
	prelaunchOracleAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePrelaunchOracleParams[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "prelaunch_oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(prelaunchOracleAccount, true, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_prelaunch_oracle" instruction.
func NewDeletePrelaunchOracleInstruction(
	// Params:
	perpMarketIndexParam uint16,

	// Accounts:
	adminAccount solanago.PublicKey,
	prelaunchOracleAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeletePrelaunchOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `perpMarketIndexParam`:
		err = enc__.Encode(perpMarketIndexParam)
		if err != nil {
			return nil, errors.NewField("perpMarketIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "prelaunch_oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(prelaunchOracleAccount, true, false))
		// Account 2 "perp_market": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, false, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_pyth_pull_oracle" instruction.
func NewInitializePythPullOracleInstruction(
	// Params:
	feedIdParam [32]uint8,

	// Accounts:
	adminAccount solanago.PublicKey,
	pythSolanaReceiverAccount solanago.PublicKey,
	priceFeedAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePythPullOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feedIdParam`:
		err = enc__.Encode(feedIdParam)
		if err != nil {
			return nil, errors.NewField("feedIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "pyth_solana_receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(pythSolanaReceiverAccount, false, false))
		// Account 2 "price_feed": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(priceFeedAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_pyth_lazer_oracle" instruction.
func NewInitializePythLazerOracleInstruction(
	// Params:
	feedIdParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	lazerOracleAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializePythLazerOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feedIdParam`:
		err = enc__.Encode(feedIdParam)
		if err != nil {
			return nil, errors.NewField("feedIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "lazer_oracle": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lazerOracleAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "post_pyth_lazer_oracle_update" instruction.
func NewPostPythLazerOracleUpdateInstruction(
	// Params:
	pythMessageParam []byte,

	// Accounts:
	keeperAccount solanago.PublicKey,
	pythLazerStorageAccount solanago.PublicKey,
	ixSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PostPythLazerOracleUpdate[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pythMessageParam`:
		err = enc__.Encode(pythMessageParam)
		if err != nil {
			return nil, errors.NewField("pythMessageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "keeper": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(keeperAccount, true, true))
		// Account 1 "pyth_lazer_storage": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(pythLazerStorageAccount, false, false))
		// Account 2 "ix_sysvar": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ixSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_high_leverage_mode_config" instruction.
func NewInitializeHighLeverageModeConfigInstruction(
	// Params:
	maxUsersParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	highLeverageModeConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeHighLeverageModeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxUsersParam`:
		err = enc__.Encode(maxUsersParam)
		if err != nil {
			return nil, errors.NewField("maxUsersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "high_leverage_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(highLeverageModeConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_high_leverage_mode_config" instruction.
func NewUpdateHighLeverageModeConfigInstruction(
	// Params:
	maxUsersParam uint32,
	reduceOnlyParam bool,
	currentUsersParam *uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	highLeverageModeConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateHighLeverageModeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxUsersParam`:
		err = enc__.Encode(maxUsersParam)
		if err != nil {
			return nil, errors.NewField("maxUsersParam", err)
		}
		// Serialize `reduceOnlyParam`:
		err = enc__.Encode(reduceOnlyParam)
		if err != nil {
			return nil, errors.NewField("reduceOnlyParam", err)
		}
		// Serialize `currentUsersParam` (optional):
		{
			if currentUsersParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("currentUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("currentUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(currentUsersParam)
				if err != nil {
					return nil, errors.NewField("currentUsersParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "high_leverage_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(highLeverageModeConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_protected_maker_mode_config" instruction.
func NewInitializeProtectedMakerModeConfigInstruction(
	// Params:
	maxUsersParam uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	protectedMakerModeConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeProtectedMakerModeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxUsersParam`:
		err = enc__.Encode(maxUsersParam)
		if err != nil {
			return nil, errors.NewField("maxUsersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "protected_maker_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protectedMakerModeConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_protected_maker_mode_config" instruction.
func NewUpdateProtectedMakerModeConfigInstruction(
	// Params:
	maxUsersParam uint32,
	reduceOnlyParam bool,
	currentUsersParam *uint32,

	// Accounts:
	adminAccount solanago.PublicKey,
	protectedMakerModeConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateProtectedMakerModeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxUsersParam`:
		err = enc__.Encode(maxUsersParam)
		if err != nil {
			return nil, errors.NewField("maxUsersParam", err)
		}
		// Serialize `reduceOnlyParam`:
		err = enc__.Encode(reduceOnlyParam)
		if err != nil {
			return nil, errors.NewField("reduceOnlyParam", err)
		}
		// Serialize `currentUsersParam` (optional):
		{
			if currentUsersParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("currentUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("currentUsersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(currentUsersParam)
				if err != nil {
					return nil, errors.NewField("currentUsersParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "protected_maker_mode_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protectedMakerModeConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "admin_deposit" instruction.
func NewAdminDepositInstruction(
	// Params:
	marketIndexParam uint16,
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	spotMarketVaultAccount solanago.PublicKey,
	adminTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AdminDeposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `marketIndexParam`:
		err = enc__.Encode(marketIndexParam)
		if err != nil {
			return nil, errors.NewField("marketIndexParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "user": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, false))
		// Account 2 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 3 "spot_market_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(spotMarketVaultAccount, true, false))
		// Account 4 "admin_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminTokenAccountAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_if_rebalance_config" instruction.
func NewInitializeIfRebalanceConfigInstruction(
	// Params:
	paramsParam IfRebalanceConfigParams,

	// Accounts:
	adminAccount solanago.PublicKey,
	ifRebalanceConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeIfRebalanceConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "if_rebalance_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ifRebalanceConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 3 "rent": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_if_rebalance_config" instruction.
func NewUpdateIfRebalanceConfigInstruction(
	// Params:
	paramsParam IfRebalanceConfigParams,

	// Accounts:
	adminAccount solanago.PublicKey,
	ifRebalanceConfigAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateIfRebalanceConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, true, true))
		// Account 1 "if_rebalance_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ifRebalanceConfigAccount, true, false))
		// Account 2 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_feature_bit_flags_mm_oracle" instruction.
func NewUpdateFeatureBitFlagsMmOracleInstruction(
	// Params:
	enableParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFeatureBitFlagsMmOracle[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `enableParam`:
		err = enc__.Encode(enableParam)
		if err != nil {
			return nil, errors.NewField("enableParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "zero_mm_oracle_fields" instruction.
func NewZeroMmOracleFieldsInstruction(
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	perpMarketAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "perp_market": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perpMarketAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_feature_bit_flags_median_trigger_price" instruction.
func NewUpdateFeatureBitFlagsMedianTriggerPriceInstruction(
	// Params:
	enableParam bool,

	// Accounts:
	adminAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFeatureBitFlagsMedianTriggerPrice[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `enableParam`:
		err = enc__.Encode(enableParam)
		if err != nil {
			return nil, errors.NewField("enableParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
